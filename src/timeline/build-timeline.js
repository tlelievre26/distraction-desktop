/* eslint-disable no-console */

const { convertTime, getTimeSpent } = require("./calc-time");

const calcMetrics = (data, sessionId) => {
  console.log("Calculating metrics for session ", sessionId);
  //Filling this with default values just to create a schema of our metrics
  const sampleMetrics = {
    //In reality, all of these except duration would be generated by a "process session ID" call of some kind
    numTasks: 10, // Number of tasks completed
    tabSwitchRate: 2, // # of times tabs were switched divided by number of minutes in session
    timeOnDistr: 1000, // Secs of time spent on apps labeled as distractions, probably won't keep this
    productivityEstimate: 8, // This isn't a real metric I just couldn't think of anything else
    mostUsedApps: [ //List of the apps with the most time spent across the session
      // App Name, total usage duration in minutes, number of times you switched to the app
      { appName: "App1", duration: 60 * 50, countSwitchedTo: 50 },
      { appName: "App2.com", duration: 60 * 40, countSwitchedTo: 30 },
      { appName: "App3", duration: 60 * 30, countSwitchedTo: 40 },
      { appName: "App4.edu", duration: 60 * 25, countSwitchedTo: 20 },
      { appName: "App5", duration: 60 * 15, countSwitchedTo: 7 }
    ]
        
  };
  return sampleMetrics;
};

const calcAppSpecificMetrics = (appName, sessionData) => {
  console.log("Calculating metrics for " + appName);
  filteredByAppName = sessionData.map((item, index) => ({ ...item, arrayIndex: index })).filter(app => app._value === appName);
  length = filteredByAppName.length;
  getUTCTime = convertTime(filteredByAppName);
  getTotalTimeSpent = getTimeSpent(getUTCTime); 
  totalTimeSpent = getTotalTimeSpent.reduce((acc, item) => acc + item, 0) / 60;

  const nextAppCounts = {};
  frequentSwitches = filteredByAppName.map((item) => {
    const nextApp = item.arrayIndex + 1 < sessionData.length ? sessionData[item.arrayIndex + 1]._value : "End of session";
    nextAppCounts[nextApp] = (nextAppCounts[nextApp] || 0) + 1;
  });

  const sortedNextApps = Object.entries(nextAppCounts)
    .map(([app, count]) => ({ app, count }))
    .sort((a, b) => b.count - a.count);  // Sort by count, descending

  getTimeBetweenSwitches = getUTCTime.map((element, index, array) => {
    return (index < array.length - 1) ? (array[index+1] - element) : 0;
  });
  
  console.log(sortedNextApps);
  const appMetrics = [
    {numTimesSwitchedTo: length},
    {totalTimeSpent: totalTimeSpent}, // displays in minutes
    {avgTimeBetweenSwitches: getTimeBetweenSwitches.reduce((acc, item) => item > 5 ? acc + item : acc, 0) / (length * 60)},
    {appsMostFrequentlyUsed: {appName: sortedNextApps[0].app, count: sortedNextApps[0].count}},
    {magicDistractionScore: totalTimeSpent / length}
  ];

  console.log(appMetrics);

  return appMetrics;
};

const chunkData = (sessionData) => {

  const data = { chunks: [] };
  time = convertTime(sessionData);
  timeConversion = getTimeSpent(time);

  timeConversion.reduce((acc, time, idx) => {
    if (acc.currentSum + time > 900) {
      if (acc.currentSum === 900 || idx === timeConversion.length - 1) { // Push the chunk if it sums to 900 or if youve reached the end of the session 
        data.chunks.push(acc.currentChunk); 
      }
      else {
        acc.currentChunk.push({name: sessionData[idx]._value, timeSpent: 900 - acc.currentSum});
        data.chunks.push(acc.currentChunk);
        time = time - (900 - acc.currentSum);
      }
      // Reset for the next chunk
      acc.currentChunk = [{name: sessionData[idx]._value, timeSpent: time}];
      acc.currentSum = time; // Reset currentSum      
    } 
    else {
      // Add to the current chunk
      acc.currentChunk.push({name: sessionData[idx]._value, timeSpent: time});
      acc.currentSum += time;
    }
    return acc;
  }, { currentChunk: [{}], currentSum: 0 });

  data.chunks.shift();
  return data;
};

module.exports = {calcMetrics, chunkData, calcAppSpecificMetrics};